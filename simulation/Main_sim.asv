%% clear the possible remnant on previous running
set(0,'defaulttextinterpreter','none');
dbclear all; %Remove breakpoints
clear;
close all;
clc;

%% Simulation Settings and Bike and General Parameters
% Gravitational Acceleration
    g = 9.81;
% Name of the model
    model = 'Main_bikesim';
% Simulation time
    sim_time = 400;
% Sampling Time
    Ts = 0.01; 
% First closest point selection in reference. Starts at 2 because the one 
% before closest is in the local reference as well
    ref_start_idx = 2; %end of page 64 of Lorenzo's thesis
% Horizon distance [m]
    hor_dis = 10; %tra cosa?
% Constant Speed [m/s]
    v = 2.4;    

% Open the Simulink Model
    open([model '.slx']);
% Choose the solver
    set_param(model,'AlgebraicLoopSolver','TrustRegion');
% Choose The Bike - Options:'red', 'black', 'green', 'scooter' or 'plastic' 
    bike = 'red';
% Load the parameters of the specified bicycle
    bike_params = LoadBikeParameters(bike); 
% bike model (for Simulink)
    bike_model = 1; % 1 = non-linear model || 2 = linear model
% 0 = Don't run test cases & save measurementdata in CSV || 1 = run test cases || 2 = generate ref yourself
    Run_tests = 0; 
% Take estimated states from a specific time if wanted (0 == initial conditions are set to zero || 1 == take from an online test)
    init = 0;
    time_start = 14.001; % what time do you want to take (if init==1)
% When you have bad GPS signal:
% Set indoor to 1 when you run the bike indoor or you have bad GPS signal
    indoor = 1; % used in Simulink
% Set badGPS=1 to make the GPS signal steady from the beginning of the sim.
    badGPS = 1; % used in Simulink
% Set compare_flag=1 if you want to compare two simulation results
    compare_flag = 0;
%% Initial states
if init == 1

    % data_lab = readtable('Logging_data\Test_session_14_06\data_8.csv');
    data_lab = readtable('Logging_data\Test_session_27_06\data_15.csv');

    %Delete the data before reseting the trajectory and obtain X/Y position
    reset_traj = find(data_lab.ResetTraj==1,1,'last');
    data_lab(1:reset_traj,:) = [];
    longitude0 = deg2rad(11);
    latitude0 = deg2rad(57);
    Earth_rad = 6371000.0;
    
    X = Earth_rad * (data_lab.LongGPS_deg_ - longitude0) * cos(latitude0);
    Y = Earth_rad * (data_lab.LatGPS_deg_ - latitude0);

    % Obtain the relative time of the data
%     Y = round(X,N) 
    data_lab.Time = round((data_lab.Time_ms_- data_lab.Time_ms_(1))*0.001, 4);
    index = find(data_lab.Time == time_start);

    initial_state.roll = data_lab.StateEstimateRoll_rad_(index);
    initial_state.roll_rate = data_lab.StateEstimateRollrate_rad_s_(index);
    initial_state.steering = data_lab.StateEstimateDelta_rad_(index);
    initial_state_estimate.x = data_lab.StateEstimateX_m_(index) - X(1);
    initial_state_estimate.y = data_lab.StateEstimateY_m_(index) - Y(1);
    initial_state_estimate.heading = data_lab.StateEstimatePsi_rad_(index);

elseif init == 0
    initial_state.roll = deg2rad(0);
    initial_state.roll_rate = deg2rad(0);
    initial_state.steering = deg2rad(0);
    initial_state.x = 1; %why 1 and not 0?
    initial_state.y = 0;
    initial_state.heading = deg2rad(0);
    initial_pose=[initial_state.x; initial_state.y; initial_state.heading];
else
    disp('Bad initialization');
end

%% Reference trajectory generation
%SHAPE options:sharp_turn, line, infinite, circle, ascent_sin, smooth_curve
type = 'circle';
% Distance between points
ref_dis = 0.5;
% Number of reference points
N = 80; 
% Scale (only for infinite and circle)
scale = 40; 

[Xref,Yref,Psiref] = Trajectory(Run_tests);

test_curve=[Xref,Yref,Psiref];
Nn = size(test_curve,1); % needed for simulink

%% OWN TRAJECTORY
% if Run_tests == 2
%[Xref,Yref,Psiref] = ReferenceGenerator(type,ref_dis,N,scale);
% test_trajectory();
% data = fileread('trajectory.txt');
% test_curve=[Xref,Yref,Psiref];
% Nn = size(test_curve,1); % needed for simulink
% end

%% Reference test (warnings and initialization update)
if ((Run_tests == 0 || Run_tests == 2) && init == 0)

    Output_reference_test = referenceTest(test_curve,hor_dis,Ts,initial_pose,v, ref_dis);
    
    % update initial states if offset is detected
    initial_state.x = Output_reference_test(1);
    initial_state.y = Output_reference_test(2);
    initial_state.heading = Output_reference_test(3);
    initial_state.heading = Psiref(3);
    initial_pose = [initial_state.x; initial_state.y; initial_state.heading];
    initial_state_estimate = initial_state;
end

%% Unpacked bike_params
h = bike_params.h_mod;
lr = bike_params.lr_mod;
lf = bike_params.lf_mod; 
lambda = bike_params.lambda_mod;
c = bike_params.c_mod;
m = bike_params.m_mod;
h_imu = bike_params.IMU_height_mod;

T = TransMatrix(bike_params);                                             

%% Disturbance Model
% 
% % Roll Reference  
% roll_ref_generation;%long time ago left by other students, it's helpless now but keep it
% 
% % Steering Rate State Perturbation
% pert_deltadot_state = 0; % Switch ON (1) / OFF (0) the perturbation
% pert_deltadot_state_fun = @(time)  -0.5*(time>10) && (ceil(mod(time/3,2)) == 1) &&(time<30);
% 
% % Roll Rate State Perturbation
% pert_phidot_state = 0; % Switch ON (1) / OFF (0) the perturbation
% pert_phidot_state_fun = @(time) cos(time)*(time>10 && time < 10.4);

%% Bike State-Space Model

% Continuous-Time Model

% % Controllable Canonical Form
%     A = [0 g/bike_params.h ; 1 0];
%     B = [1 ; 0];
%     C = [bike_params.a*v/(bike_params.b*bike_params.h) g*bike_params.inertia_front/(bike_params.h^3*bike_params.m)+v^2/(bike_params.b*bike_params.h)];
%     D = [bike_params.inertia_front/(bike_params.h^2*bike_params.m)];

% % Observable Canonical Form
%     A = [0 g/bike_params.h ; 1 0];
%     B = [g*bike_params.inertia_front/(bike_params.h^3*bike_params.m)+(v^2./(bike_params.b*bike_params.h)-bike_params.a*bike_params.c*g/(bike_params.b*bike_params.h^2)).*sin(bike_params.lambda) ;
%         bike_params.a*v/(bike_params.b*bike_params.h).*sin(bike_params.lambda)];
%     C = [0 1];
%     D = [bike_params.inertia_front/(bike_params.h^2*bike_params.m)];
% 
% % Linearized System
%     linearized_sys = ss(A,B,C,D);
% % Augmented System
%     fullstate_sys = ss(linearized_sys.A,linearized_sys.B,eye(size(linearized_sys.A)),0);
% % Discretized System
%     discretized_sys = c2d(linearized_sys,Ts);

%% Balancing Controller
%Remove I and D?
% Outer loop -- Roll Tracking
P_balancing_outer = 3.75;
I_balancing_outer = 0.0;
D_balancing_outer = 0.0;

% Inner loop -- Balancing
P_balancing_inner = 3.5;
I_balancing_inner = 0;
D_balancing_inner = 0;  

%% The LQR controller
[k1,k2,e1_max,e2_max] = LQRcontroller(v,lr,lf);

%% Transfer function for heading in wrap traj
%feed forward trasfer function for d_psiref to steering reference (steering contribution for heading changes)
num = 1;
den = [lr/(lr+lf), v/(lr+lf)];
[A_t, B_t, C_t, D_t] = tf2ss(num,den);

% Discretize the ss 
% Used in Simulink
Ad_t = (eye(size(A_t))+Ts*A_t);
Bd_t = B_t*Ts;

%% Kalman Filter
% Load the Q and R matrices
load('Q_and_R_backup_red_bike.mat');

[K_GPS,K_noGPS,counter,A_d,B_d,C,D] = KalmanFilter(v,h,lr,lf,lambda,g,c,h_imu,Ts,Q,R);

save('K_noGPS.mat','K_noGPS');

%% Save matrix in XML/CSV
matrixmat = [A_d; B_d'; C; D';K_GPS; K_noGPS]; 
SaveInCSV(matrixmat,test_curve);

%% Start the Simulation
if Run_tests == 0 || Run_tests == 2
tic
try 
    Results = sim(model); % If no error occurs, MATLAB skips the catch.
    catch error_details %note: the model has runned for one time here
end
toc

% Simulation Messages and Warnings
% if Results.stop.Data(end) == 1
%     disp('Message: End of the trajectory has been reached');
% end

%% Plotting
PlottingResults(test_curve,Results,compare_flag);
end

%% Test cases for validation
TestCases(Run_tests,hor_dis,Ts,initial_pose);
